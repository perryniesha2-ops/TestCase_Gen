import { NextResponse } from "next/server";
import JSZip from "jszip";
import crypto from "node:crypto";
import { createClient } from "@/lib/supabase/server";

export const runtime = "nodejs";

type TestStep = {
  step_number?: number;
  action: string;
  expected: string;
};

type TestCaseRow = {
  id: string;
  title: string;
  description: string | null;
  test_type: string | null;
  expected_result: string | null;
  test_steps: unknown;
};

type SuiteRow = {
  id: string;
  name: string;
  description?: string | null;
};

type SuiteLinkRow = {
  id: string;
  test_case_id: string;
  sequence_order: number | null;
  priority: string | null;
  estimated_duration_minutes: number | null;
};

function safeSlug(input: string) {
  return String(input || "")
    .trim()
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/(^-|-$)/g, "")
    .slice(0, 60);
}

function parseSteps(raw: unknown): TestStep[] {
  if (!raw) return [];

  if (Array.isArray(raw)) {
    return raw
      .map((s: any) => ({
        step_number: Number.isFinite(s?.step_number)
          ? Number(s.step_number)
          : undefined,
        action: String(s?.action ?? "").trim(),
        expected: String(s?.expected ?? "").trim(),
      }))
      .filter((s) => s.action.length > 0 || s.expected.length > 0);
  }

  if (typeof raw === "string") {
    try {
      return parseSteps(JSON.parse(raw));
    } catch {
      return [];
    }
  }

  if (typeof raw === "object") {
    try {
      const arr = Object.values(raw as Record<string, any>);
      return parseSteps(arr);
    } catch {
      return [];
    }
  }

  return [];
}

function escapeTemplateLiteral(s: string) {
  return s.replace(/`/g, "\\`").replace(/\$\{/g, "\\${");
}

function renderReadme(opts: {
  suiteName: string;
  suiteId: string;
  caseCount: number;
}) {
  return `# SynthQA Playwright Project

This project was generated by SynthQA.

## Suite
- Name: ${opts.suiteName}
- ID: ${opts.suiteId}
- Test cases: ${opts.caseCount}

## Prerequisites
- Node.js 18+

## Install
\`\`\`bash
pnpm i
npx playwright install
\`\`\`

## Configure
Copy \`.env.example\` to \`.env\` and set:

- BASE_URL="https://your-app-url"
- (optional) USER_EMAIL, USER_PASSWORD

## Run
\`\`\`bash
pnpm test
\`\`\`

## Report
After running:
- HTML report: ./playwright-report
- Raw results: ./test-results

## Notes (v1)
These tests are scaffolds designed to run on any site.
They will:
- Navigate to BASE_URL
- Log each test step as a Playwright test.step
- Capture screenshots per step
- Include TODO blocks for implementing selectors and assertions
`;
}

function renderEnvExample() {
  return `# Required
BASE_URL="https://app.example.com"

# Optional (if you later implement login helpers)
USER_EMAIL=""
USER_PASSWORD=""
`;
}

function renderGitignore() {
  return `node_modules
playwright-report
test-results
.env
`;
}

function renderPackageJson() {
  return JSON.stringify(
    {
      name: "synthqa-playwright",
      private: true,
      type: "module",
      scripts: {
        test: "playwright test",
        "test:ui": "playwright test --ui",
        report: "playwright show-report",
      },
      devDependencies: {
        "@playwright/test": "^1.46.0",
        dotenv: "^16.4.5",
        typescript: "^5.5.4",
      },
    },
    null,
    2,
  );
}

function renderTsconfig() {
  return JSON.stringify(
    {
      compilerOptions: {
        target: "ES2022",
        module: "ESNext",
        moduleResolution: "Bundler",
        strict: true,
        esModuleInterop: true,
        skipLibCheck: true,
        types: ["node"],
      },
      include: ["tests", "playwright.config.ts", "synthqa"],
    },
    null,
    2,
  );
}

function renderPlaywrightConfig() {
  return `import { defineConfig } from "@playwright/test";
import "dotenv/config";

export default defineConfig({
  testDir: "./tests",
  timeout: 60_000,
  expect: { timeout: 10_000 },
  retries: 1,
  reporter: [["html", { open: "never" }], ["list"]],
  use: {
    baseURL: process.env.BASE_URL,
    headless: true,
    trace: "on-first-retry",
    screenshot: "on",
    video: "retain-on-failure",
  },
});
`;
}

function renderCaseSpec(opts: {
  suiteId: string;
  caseKey: string;
  caseId: string;
  title: string;
}) {
  return `import { test, expect } from "@playwright/test";
import fs from "node:fs";
import path from "node:path";

type SynthQACase = {
  id: string;
  title: string;
  description: string | null;
  expected_result: string | null;
  test_type: string | null;
  test_steps: Array<{ step_number?: number; action: string; expected: string }>;
};

const caseData: SynthQACase = JSON.parse(
  fs.readFileSync(
    path.join(process.cwd(), "synthqa", "cases", "${opts.caseKey}.json"),
    "utf8"
  )
);

test.describe(\`${escapeTemplateLiteral(opts.title)}\`, () => {
  test(\`${opts.caseId}\`, async ({ page }, testInfo) => {
    const baseUrl = process.env.BASE_URL;
    if (!baseUrl) throw new Error("Missing BASE_URL in environment (.env)");

    await test.step("Navigate to BASE_URL", async () => {
      await page.goto(baseUrl, { waitUntil: "domcontentloaded" });
      await page.waitForTimeout(500);
    });

    for (const step of caseData.test_steps) {
      const n = step.step_number ?? 0;
      await test.step(\`Step \${n}: \${step.action}\`, async () => {
        // TODO: Implement action:
        //   ${"${"}step.action${"}"}

        // TODO: Assert expected:
        //   ${"${"}step.expected${"}"}

        await page.screenshot({
          path: testInfo.outputPath(\`step-\${n || "x"}.png\`),
          fullPage: true,
        });

        // Sanity check (keeps the run stable unless hard failures occur)
        await expect(page).toHaveURL(/.*/);
      });
    }

    await test.step("Expected Result placeholder", async () => {
      // TODO: Verify overall expected result:
      //   ${"${"}caseData.expected_result${"}"}
      await page.screenshot({
        path: testInfo.outputPath("final.png"),
        fullPage: true,
      });
    });
  });
});
`;
}

export async function POST(req: Request) {
  try {
    const body = (await req.json().catch(() => null)) as {
      suiteId?: string;
    } | null;

    const suiteId = body?.suiteId?.trim();
    if (!suiteId) {
      return NextResponse.json(
        { ok: false, error: "Missing suiteId" },
        { status: 400 },
      );
    }

    const supabase = await createClient();

    const {
      data: { user },
      error: userErr,
    } = await supabase.auth.getUser();
    if (userErr) {
      return NextResponse.json(
        { ok: false, error: userErr.message },
        { status: 401 },
      );
    }
    if (!user) {
      return NextResponse.json(
        { ok: false, error: "Not authenticated" },
        { status: 401 },
      );
    }

    // Fetch suite
    const { data: suite, error: suiteErr } = await supabase
      .from("test_suites")
      .select("id, name, description")
      .eq("id", suiteId)
      .single<SuiteRow>();

    if (suiteErr || !suite) {
      return NextResponse.json(
        { ok: false, error: suiteErr?.message || "Suite not found" },
        { status: 404 },
      );
    }

    // Fetch suite links
    const { data: suiteLinks, error: linksErr } = await supabase
      .from("test_suite_cases")
      .select(
        "id, test_case_id, sequence_order, priority, estimated_duration_minutes",
      )
      .eq("suite_id", suiteId)
      .order("sequence_order", { ascending: true })
      .returns<SuiteLinkRow[]>();

    if (linksErr) {
      return NextResponse.json(
        { ok: false, error: linksErr.message },
        { status: 500 },
      );
    }

    if (!suiteLinks || suiteLinks.length === 0) {
      return NextResponse.json(
        { ok: false, error: "No test cases linked to this suite" },
        { status: 400 },
      );
    }

    const testCaseIds = suiteLinks.map((l) => l.test_case_id);

    // Fetch test cases
    const { data: testCases, error: casesErr } = await supabase
      .from("test_cases")
      .select("id, title, description, test_type, expected_result, test_steps")
      .in("id", testCaseIds)
      .returns<TestCaseRow[]>();

    if (casesErr) {
      return NextResponse.json(
        { ok: false, error: casesErr.message },
        { status: 500 },
      );
    }

    const tcMap = new Map((testCases || []).map((tc) => [tc.id, tc]));

    const ordered = suiteLinks
      .map((link, idx) => {
        const tc = tcMap.get(link.test_case_id);
        if (!tc) return null;
        const steps = parseSteps(tc.test_steps);
        const caseKey = `${String(link.sequence_order ?? idx + 1).padStart(
          3,
          "0",
        )}-${safeSlug(tc.title)}-${tc.id.slice(0, 8)}`;

        return {
          link,
          tc,
          steps,
          caseKey,
        };
      })
      .filter((x): x is NonNullable<typeof x> => Boolean(x));

    // --------------------------
    // Zip project
    // --------------------------
    const zip = new JSZip();
    const root = `synthqa-playwright-${
      safeSlug(suite.name) || "suite"
    }-${suite.id.slice(0, 8)}`;

    const add = (p: string, content: string) =>
      zip.file(`${root}/${p}`, content);

    add("package.json", renderPackageJson());
    add("playwright.config.ts", renderPlaywrightConfig());
    add("tsconfig.json", renderTsconfig());
    add(".env.example", renderEnvExample());
    add(".gitignore", renderGitignore());
    add(
      "README.md",
      renderReadme({
        suiteName: suite.name,
        suiteId: suite.id,
        caseCount: ordered.length,
      }),
    );

    // Suite snapshot
    const suiteSnapshot = {
      generatedAt: new Date().toISOString(),
      suite: {
        id: suite.id,
        name: suite.name,
        description: suite.description ?? null,
      },
      cases: ordered.map((o) => ({
        id: o.tc.id,
        title: o.tc.title,
        sequence_order: o.link.sequence_order ?? null,
        priority: o.link.priority ?? null,
        estimated_duration_minutes: o.link.estimated_duration_minutes ?? null,
        caseKey: o.caseKey,
      })),
    };
    add("synthqa/suite.json", JSON.stringify(suiteSnapshot, null, 2));

    for (const o of ordered) {
      const caseJson = {
        id: o.tc.id,
        title: o.tc.title,
        description: o.tc.description ?? null,
        test_type: o.tc.test_type ?? null,
        expected_result: o.tc.expected_result ?? null,
        test_steps: o.steps.map((s, i) => ({
          step_number: s.step_number ?? i + 1,
          action: s.action,
          expected: s.expected,
        })),
      };

      add(`synthqa/cases/${o.caseKey}.json`, JSON.stringify(caseJson, null, 2));
      add(
        `tests/cases/${o.caseKey}.spec.ts`,
        renderCaseSpec({
          suiteId: suite.id,
          caseKey: o.caseKey,
          caseId: o.tc.id,
          title: o.tc.title,
        }),
      );
    }

    const zipBuffer = await zip.generateAsync({ type: "nodebuffer" });
    const fileName = `${root}.zip`;

    return new Response(new Uint8Array(zipBuffer), {
      status: 200,
      headers: {
        "Content-Type": "application/zip",
        "Content-Disposition": `attachment; filename="${fileName}"`,
        "Cache-Control": "no-store",
        "X-Content-Type-Options": "nosniff",
      },
    });
  } catch (e: any) {
    console.error("[export/playwright] error:", e);
    return NextResponse.json(
      { ok: false, error: e?.message || "Export failed" },
      { status: 500 },
    );
  }
}
